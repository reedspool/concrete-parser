#+TITLE: Parse Machine Tests
#+PROPERTY: header-args    :comments both :tangle ../test/ParseMachine.test.js

* Preamble

#+begin_src js
import * as ParseMachine from "../src/ParseMachine.js";
import { Machine, interpret } from "xstate";
import { Token } from "../src/LexicalToken";
import { Block, Tape } from "../src/Block";
import { InvertedPromise as Promise } from "inverted-promise";
import { AbstractSyntaxTree } from "../src/AbstractSyntaxTree"
import { TestInterpreter, toMatchState } from "xstate-jest-tools";
expect.extend({ toMatchState });

const parseMachine =
    Machine(ParseMachine.definition)
        .withConfig(ParseMachine.config)
        // Supply empty context to avoid warning
        .withContext({});

let interpreter;
let tree;

beforeEach(() => {
    tree = AbstractSyntaxTree();
    interpreter = TestInterpreter(parseMachine);
})
#+end_src

* Simple
Start with the simplest test:

#+begin_src js
it("Starts empty", () => {
    expect(interpreter.S).toMatchState("ready");
    expect(interpreter.C.tree).toEqual(AbstractSyntaxTree());
})
#+end_src

Now let's send  the simplest case, the blank block, =_=.

#+begin_src js
it("Parses just a blank", () => {
    tree.appendValueBlock(Token.Blank.create());

    interpreter.send(Token.Blank.create());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(tree);
})
#+end_src

* Labels

Labels are a quality of a tape. They name the specific cell of the block which comes after them.

#+begin_src js
it("Parses a blank with a label", () => {
    tree.labelNextCell(Token.LabelIdentifier.create("abcd"));
    tree.appendValueBlock(Token.Blank.create());
    interpreter.send(Token.LabelIdentifier.create("abcd"));
    interpreter.send(Token.Blank.create());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(tree);
    expect(interpreter.C.tree.tape.labelsByIndex[0])
        .toEqual("abcd");
    expect(interpreter.C.tree.tape.labelsToIndex["abcd"])
        .toEqual(0);
})
#+end_src

#+begin_src js
it("A label followed by a label is an error", () => {
    interpreter.send(Token.LabelIdentifier.create("abcd"));
    expect(interpreter.S).toMatchState("ready.label.expectingBlock");
    const fn = () =>
        interpreter.send(Token.LabelIdentifier.create("abcd"));

    expect(fn).toThrowError();
})
#+end_src

#+begin_src js
it("A label at the end of a tape is an error", () => {
    interpreter.send(Token.LabelIdentifier.create("abcd"));
    expect(interpreter.S).toMatchState("ready.label.expectingBlock");
    const fn = () =>
          interpreter.send("DONE");
    expect(fn).toThrowError();
})
#+end_src

* Commas

#+begin_src js
it("Parses some value blocks with commas", () => {
    tree.appendComma();
    tree.appendValueBlock(Token.Blank.create());
    tree.appendValueBlock(Token.Blank.create());
    tree.appendComma();
    interpreter.send(Token.Comma.create());
    interpreter.send(Token.Blank.create());
    interpreter.send(Token.Blank.create());
    interpreter.send(Token.Comma.create());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(tree);
    expect(interpreter.C.tree.tape.cells).toHaveLength(2);
    expect(interpreter.C.tree.tape.commas[0]).toBeTruthy();
    expect(interpreter.C.tree.tape.commas[2]).toBeTruthy();
})
#+end_src

* Tapes

#+begin_src js
it("Parses just an empty tape", () => {
    tree.openTape();
    tree.closeTape();
    interpreter.send(Token.OpenTape.create());
    interpreter.send(Token.CloseTape.create());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(tree);
    expect(interpreter.C.tree.tape.cells).toHaveLength(1);
    expect(interpreter.C.tree.tape.cells[0]).toEqual(Tape());
})
#+end_src

Tape with params

#+begin_src js
it("Parses an empty tape with an empty param list", () => {
    tree.openTape();
    tree.closeTape();
    interpreter.send(Token.OpenParams.create());
    expect(interpreter.S).toMatchState("ready.params.open");
    interpreter.send(Token.CloseParams.create());
    expect(interpreter.S).toMatchState("ready.params.expectingTape");
    interpreter.send(Token.OpenTape.create());
    interpreter.send(Token.CloseTape.create());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(tree);
    expect(interpreter.C.tree.tape.cells).toHaveLength(1);
    expect(interpreter.C.tree.tape.cells[0]).toEqual(Tape());
})
#+end_src

#+begin_src js
it("Parses an empty tape with a param list", () => {
    tree.addParamForNextTape(Token.ValueIdentifier.create("meow"));
    tree.addParamForNextTape(Token.LabelIdentifier.create("abcd"));
    tree.addParamForNextTape(Token.ValueIdentifier.create("cheese"));
    tree.openTape();
    tree.closeTape();
    interpreter.send(Token.OpenParams.create());
    expect(interpreter.S).toMatchState("ready.params.open");
    interpreter.send(Token.ValueIdentifier.create("meow"));
    interpreter.send(Token.LabelIdentifier.create("abcd"));
    expect(interpreter.S).toMatchState("ready.params.expectingDefaultValue");
    interpreter.send(Token.ValueIdentifier.create("cheese"));
    interpreter.send(Token.CloseParams.create("meow"));
    expect(interpreter.S).toMatchState("ready.params.expectingTape");
    interpreter.send(Token.OpenTape.create());
    interpreter.send(Token.CloseTape.create());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(tree);
    expect(interpreter.C.tree.tape.cells).toHaveLength(1);
})
#+end_src

#+begin_src js
it("Duplicate parameter labels error", () => {
    interpreter.send(Token.OpenParams.create());
    expect(interpreter.S).toMatchState("ready.params.open");
    interpreter.send(Token.ValueIdentifier.create("meow"));
    const fn = () => interpreter.send(Token.LabelIdentifier.create("meow"));

    expect(fn).toThrowError();
})
#+end_src

* XState Interpreter =onDone()=

The machine should reach a final state if the input comes from =streamFile=.

#+begin_src js
it("XState interpreter onDone called successfully on empty file", async () => {
    const interpreter = interpret(parseMachine);
    const promise = Promise();

    interpreter.onDone(({ data }) => promise.resolve(data));
    interpreter.start();

    interpreter.send("DONE");
    expect(await promise).toEqual(tree);
    interpreter.stop();
})
#+end_src

#+begin_src js
it("XState interpreter onDone called successfully on non-empty file", async () => {
    const interpreter = interpret(parseMachine);
    const promise = Promise();

    tree.appendValueBlock(Token.Number.create("3"));

    interpreter.onDone(({ data }) => promise.resolve(data));
    interpreter.start();

    interpreter.send(Token.Number.create("3"));
    interpreter.send("DONE");
    expect(await promise).toEqual(tree);
    interpreter.stop();
})
#+end_src
