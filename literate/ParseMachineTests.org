#+TITLE: Parse Machine Tests
#+PROPERTY: header-args    :comments both :tangle ../test/ParseMachine.test.js

* Preamble

#+begin_src js
import * as ParseMachine from "../src/ParseMachine.js";
import { Machine, interpret } from "xstate";
import { Token } from "../src/LexicalToken";
import { InvertedPromise as Promise } from "../src/InvertedPromise";
import { AbstractSyntaxTree } from "../src/AbstractSyntaxTree"
import { TestInterpreter, toMatchState } from "xstate-jest-tools";
expect.extend({ toMatchState });

const parseMachine =
    Machine(ParseMachine.definition)
        .withConfig(ParseMachine.config)
        // Supply empty context to avoid warning
        .withContext({});

let interpreter;
let tree;

beforeEach(() => {
    tree = AbstractSyntaxTree();
    interpreter = TestInterpreter(parseMachine);
})
#+end_src

* Simple
Start with the simplest test:

#+begin_src js
it("Starts empty", () => {
    expect(interpreter.S).toMatchState("ready");
    expect(interpreter.C.tree).toEqual(AbstractSyntaxTree());
})
#+end_src

Now let's send  the simplest case, the blank block, =_=.

#+begin_src js
it("Parses just a blank", () => {
    tree.addToCurrentTape(Token.Blank.factory());
    
    interpreter.send(Token.Blank.factory());
    interpreter.send("DONE");

    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tree).toEqual(
        tree)
})
#+end_src

* XState Interpreter =onDone()=

The machine should reach a final state if the input comes from =streamFile=.

#+begin_src js
it("XState interpreter onDone called successfully on empty file", async () => {
    const interpreter = interpret(parseMachine);
    const promise = Promise();

    interpreter.onDone(({ data }) => promise.resolve(data));
    interpreter.start();

    interpreter.send("DONE");
    expect(await promise).toEqual(tree);
    interpreter.stop();
})
#+end_src

#+begin_src js
it("XState interpreter onDone called successfully on non-empty file", async () => {
    const interpreter = interpret(parseMachine);
    const promise = Promise();
    
    tree.addToCurrentTape(Token.Number.factory("3"));

    interpreter.onDone(({ data }) => promise.resolve(data));
    interpreter.start();

    interpreter.send(Token.Number.factory("3"));
    interpreter.send("DONE");
    expect(await promise).toEqual(tree);
    interpreter.stop();
})
#+end_src
