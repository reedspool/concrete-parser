#+TITLE: Lex Machine Tests
#+PROPERTY: header-args :comments both :tangle ../test/LexMachine.test.js

* Preamble

#+begin_src js
import * as LexMachine from "../src/LexMachine.js";
import { Token } from "../src/LexicalToken";
import { interpret, Machine } from "xstate";
import { InvertedPromise as Promise } from "../src/InvertedPromise";
import { TestInterpreter, toMatchState } from "xstate-jest-tools";
import { streamFile } from "../src/CharacterStream";
expect.extend({ toMatchState });

const lexMachine =
    Machine(LexMachine.definition)
        .withConfig(LexMachine.config)
        // Supply empty context to avoid warning
        .withContext({});

let interpreter;

const streamFileCallback = (event) => {
    interpreter.send(event);
}

beforeEach(() => {
    interpreter = TestInterpreter(lexMachine);
})
#+end_src

* Basic
Start with the simplest test:

#+begin_src js
it("Starts empty", () => {
    expect(interpreter.S).toMatchState("none");
})
#+end_src

* Blank

#+begin_src js
it("Tokenizes just a blank", () => {
    streamFile("_", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.Blank.factory() ]);
})
#+end_src

* Value Identifier

Okay what about a complete identifier?

#+begin_src js
it("Lexes a simple alphabetic ValueIdentifier", () => {
    streamFile("abc", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.ValueIdentifier.factory("abc") ]);
})
#+end_src

Okay what about more complex identifiers

#+begin_src js
it("Lexes a complex mixed ValueIdentifier", () => {
    streamFile("a0_z", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.ValueIdentifier.factory("a0_z") ]);
})
#+end_src

* Address Identifier

Okay what about a complete identifier?

#+begin_src js
it("Lexes a simple alphabetic AddressIdentifier", () => {
    streamFile("@abc", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.AddressIdentifier.factory("@abc") ]);
})
#+end_src

Okay what about more complex identifiers

#+begin_src js
it("Lexes a complex mixed AddressIdentifier", () => {
    streamFile("@a0_z", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.AddressIdentifier.factory("@a0_z") ]);
})
#+end_src

* Label Identifiers

#+begin_src js
it("Lexes a simple alphabetic LabelIdentifier", () => {
    streamFile("abc:", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.LabelIdentifier.factory("abc:") ]);
})
#+end_src

Okay what about more complex identifiers

#+begin_src js
it("Lexes a complex mixed LabelIdentifier", () => {
    streamFile("a0_z:", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.LabelIdentifier.factory("a0_z:") ]);
})
#+end_src

* Call Identifiers

#+begin_src js
it("Lexes a simple alphabetic CallIdentifier", () => {
    streamFile("abc!", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.CallIdentifier.factory("abc!") ]);
})
#+end_src

Okay what about more complex identifiers

#+begin_src js
it("Lexes a complex mixed CallIdentifier", () => {
    streamFile("a0_z!", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.CallIdentifier.factory("a0_z!") ]);
})
#+end_src

* Numbers
What about integers?

#+begin_src js
it("Lexes an integer", () => {
    streamFile("33554432", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.Number.factory("33554432") ]);
})
#+end_src

Decimals?

#+begin_src js
it("Lexes a decimal", () => {
    streamFile("3355.4432", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [ Token.Number.factory("3355.4432") ]);
})
#+end_src

Numbers that end with a period are not allowed.

#+begin_src js
it("Lexing a decimal that ends with a period throws an error", () => {
    interpreter.send({ type: "NUMERIC", char: "1" });
    interpreter.send({ type: "PERIOD", char: "." });
    const fn = () => interpreter.send({ type: "EOF", char: undefined });
    expect(fn).toThrowError();
})
#+end_src

* All together

Can't be both an AddressIdentifier and a CallIdentifier

#+begin_src js
it("Cannot be both AddressIdentifier and CallIdentifier", () => {
    interpreter.send({ type: "AT_SIGN", char: "@" });
    interpreter.send({ type: "ALPHABETIC", char: "a" });
    const fn = () => interpreter.send({ type: "EXCLAMATION", char: "!" });
    expect(fn).toThrowError();
})
#+end_src

What about everything we've done so far separated by whitespace?

#+begin_src js
it("Lexes whitespace separated tokens", () => {
    streamFile("ab _ z 3 33.44", streamFileCallback);
    expect(interpreter.S).toMatchState("done");
    expect(interpreter.C.tokens).toEqual(
        [
            Token.ValueIdentifier.factory("ab"),
            Token.Blank.factory(),
            Token.ValueIdentifier.factory("z"),
            Token.Number.factory("3"),
            Token.Number.factory("33.44")
        ]);
})
#+end_src

* XState Interpreter =onDone()=

The machine should reach a final state if the input comes from =streamFile=.

#+begin_src js
it("XState interpreter onDone called successfully on empty file", async () => {
    const interpreter = interpret(lexMachine);
    const promise = Promise();
    
    interpreter.onDone(({ data }) => promise.resolve(data));
    interpreter.start();

    streamFile("", (event) => interpreter.send(event));
    expect(await promise).toEqual([]);
    interpreter.stop();
})
#+end_src

#+begin_src js
it("XState interpreter onDone called successfully on non-empty file", async () => {
    const interpreter = interpret(lexMachine);
    const promise = Promise();
    
    interpreter.onDone(({ data }) => promise.resolve(data));
    interpreter.start();

    streamFile("3", (event) => interpreter.send(event));
    expect(await promise).toEqual([Token.Number.factory("3")]);
    interpreter.stop();
})
#+end_src
